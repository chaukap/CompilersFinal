/* program4.ypp
 * Chandler Haukap
 * 10/24/19
 * COSC 4785
 *  
 * Bison file. 
 */

%{
#include <iostream>
#include "node.hpp"
#include <FlexLexer.h>
#include <queue>
using namespace std;

extern queue<Node*> classes;
extern yyFlexLexer scanner;
extern int row;
extern int column;

#define yylex() scanner.yylex()
#define yytext() scanner.YYText()

void yyerror(const char *);
%}

%union {
  Node *ttype;
}

%type<ttype> program exp vardec type ResultType classDeclaration classBody
%type<ttype> identifier name bracketexp bracketexps multibrackets newexp 
%type<ttype> varDeclarations LocalVarDec ConstructorDeclarations
%type<ttype> ConstructorDeclaration MethodDeclaration MethodDeclarations
%type<ttype> LocalVarDecs Block Statement Statements ConditionalStatement
%type<ttype> Arglist Parameter ParameterList OptionalExpression newType
%type<ttype> identifierSemi paramList ParametersAndBlock InnerBlock
%type<ttype> MoreParameters SimpleType UnaryOp
%token<ttype> NUM SEMI
%left NEQ EQ LT GT LEQ GEQ AND OR PLUS MINUS TIMES DIV MOD
%token INT IDENT COMMA DOT RPAREN LPAREN LBRACK NOT RBRACK LBRACE RBRACE IF
%token ASSIGN COMMENT VOID CLASS NEW PRINT READ RETURN ELSE NULLT THIS WHILE
%token ER_CH ER_WD ERRORS IGNORE

%% /* Grammar rules and actions follow. */
input:  
program         {}
;

program:
classDeclaration            {
                            classes.push($1);
                            }      
| program classDeclaration  {
                            classes.push($2);
                            }
| error                     {
                            cout << "(R" << row << ",C" << column << ") " 
                                 << yytext() << endl;
                            }
;

classDeclaration:
CLASS identifier LBRACE classBody RBRACE  {
                                          $$=new NodeClass($2, $4);
                                          }
| CLASS identifier LBRACE RBRACE          {
                                          $$=new NodeClass($2, 0);
                                          }
;

classBody:
varDeclarations ConstructorDeclarations MethodDeclarations  {
                                                            $$=new NodeClassBody($1, 
                                                                            $2, $3);
                                                            }
| varDeclarations                             {
                                              $$=new NodeClassBody($1);
                                              }
| varDeclarations ConstructorDeclarations     {
                                              $$=new NodeClassBody($1, $2);
                                              }
| ConstructorDeclarations                     {
                                              $$=new NodeClassBody(0, $1);
                                              }
| ConstructorDeclarations MethodDeclarations  {
                                              $$=new NodeClassBody(0, $1, $2);
                                              }
| MethodDeclarations                          {
                                              $$=new NodeClassBody(0, 0, $1);
                                              }
| varDeclarations MethodDeclarations          {
                                              $$=new NodeClassBody($1, 0, $2);
                                              }
;

varDeclarations:
vardec                    {
                          $$=$1;
                          }
| varDeclarations vardec  {
                          $$=new Node($1, $2);
                          }
;

ConstructorDeclarations:
ConstructorDeclaration                            {
                                                  $$=$1;
                                                  }  
| ConstructorDeclarations ConstructorDeclaration  {
                                                  $$=new Node($1, $2);
                                                  }
;

ConstructorDeclaration:
identifier LPAREN ParametersAndBlock  {
                                      //cout << "Constructor Declaration" << endl;
                                      $$=new NodeConstructorDec($1, $3);
                                      }
;

MethodDeclarations:
MethodDeclaration                     {
                                      $$=new Node($1);
                                      }
| MethodDeclarations MethodDeclaration  {
                                      $$=new Node($1, $2);
                                      }
;

MethodDeclaration:
ResultType identifier LPAREN ParametersAndBlock {
                                                $$=new NodeMethodDec($1, $2, $4);
                                                }
;

/* Returns a regular node. If LEFT is NULL, there is no parameter list. */
ParametersAndBlock:
ParameterList RPAREN Block  {
                            $$=new Node($1, $3);
                            }
| RPAREN Block              {
                            $$=new Node(0, $2);
                            }
;

ResultType:
type    {
        $$=$1;
        }
| VOID    {
        $$=0;
        }
;

ParameterList:
Parameter                         {
                                  $$=$1;
                                  }
| Parameter MoreParameters        {
                                  $$=new NodeParameterList($1, $2);
                                  }
;

MoreParameters:
COMMA Parameter                   {
                                  $$=$2;
                                  }
| COMMA Parameter MoreParameters  {
                                  $$=new NodeParameterList($2, $3);
                                  }
;

Parameter:
type identifier {
                $$=new NodeParameter($1, $2);
                }
;

vardec:
type identifier SEMI                  {
                                      $$=new nodeVardec($1, $2);
                                      }
| identifier identifierSemi           {
                                      $$=new nodeVardec($1,$2);
                                      }
| type multibrackets identifierSemi   {
                                      $$=new nodeVardec($1,$2,$3);
                                      }
| identifier multibrackets identifierSemi {
                                          $$=new nodeVardec($1,$2,$3);
                                          }
;

identifierSemi:
identifier SEMI   {
                  $$=$1;
                  }
;

Block:
LBRACE InnerBlock RBRACE  {
                          $$=new NodeBlock($2);
                          }
| LBRACE RBRACE             {
                          $$=0;
                          }
;

/* Returns a Node. LEFT is the LocalVarDecs and RIGHT is the Statements.
 * Either or could be NULL. */
InnerBlock:
LocalVarDecs              {
                          $$=new Node($1);
                          }
| Statements              {
                          $$=new Node(0, $1);
                          }
| LocalVarDecs Statements {
                          $$=new Node($1, $2);
                          }
;

LocalVarDecs:
LocalVarDec                 {
                            $$=$1;
                            }
| LocalVarDecs LocalVarDec  {
                            $$=new Node($1, $2);
                            }
;

Statements:
Statement             {
                      $$=$1;
                      }
| Statements Statement  {
                      $$=new Node($1, $2);
                      }
;

Statement:
name ASSIGN exp SEMI                {
                                    $$=new NodeAssign($1, $3);
                                    }
| name paramList SEMI               {
                                    $$=new NodeFunct($1, $2);
                                    }
| PRINT paramList SEMI              {
                                    $$=new NodePrint($2);
                                    }
| ConditionalStatement              {
                                    $$=$1;
                                    }
| WHILE LPAREN exp RPAREN Statement {
                                    $$=new NodeWhile($3, $5);
                                    }
| RETURN OptionalExpression         {
                                    $$=new NodeOptional($2);
                                    }
| Block                             {
                                    $$=$1;
                                    }
| SEMI
;


LocalVarDec:
type identifier SEMI  {
                      $$=new nodeVardec($1, $2);
                      }
;

Arglist:
exp                 {
                    $$=$1;
                    }
| Arglist COMMA exp {
                    $$=new Node($1, $3);
                    }
;

OptionalExpression:
SEMI        {
            $$=0;
            }
| exp SEMI  {
            $$=$1;
            }
;

ConditionalStatement:
IF LPAREN exp RPAREN Statement  {
                                $$=new NodeConditional($3, $5, 0);
                                }
| IF LPAREN exp RPAREN Statement ELSE Statement {
                                                $$=new NodeConditional($3, $5, 
                                                                       $7);
                                                }
;

exp:
name                  {
                      $$=$1;
                      }
| NULLT               {
                      $$=0;
                      }
| NUM       		      {
                      $$=new nodeNum($1->getint()); delete $1; 
                      }
| name paramList      {
                      $$=new NodeFunctionCall($1, $2);
                      }
| exp OR exp          {
                      $$=new Node($1,$3);
                      $$->setval(" || ");
                      }
| exp AND exp         {
                      $$=new Node($1,$3);
                      $$->setval(" && ");
                      }
| exp MOD exp         {
                      $$=new Node($1,$3);
                      $$->setval(" % "); 
                      }
| READ LPAREN RPAREN  {
                      $$=new NodeRead();
                      }
| exp PLUS exp        { 
                      $$=new Node($1,$3);
                      $$->setval(" + ");
                      }
| exp MINUS exp       { 
                      $$=new Node($1,$3);
                      $$->setval(" - ");
                      }
| exp TIMES exp       { 
                      $$=new Node($1,$3);
                      $$->setval(" * ");
                      }
| exp DIV exp         { 
                      $$=new Node($1,$3);
                      $$->setval(" / ");
                      }
| UnaryOp             { 
                      $$=$1;
                      }
| LPAREN exp RPAREN   { 
                      $$=new nodeParExp($2);
                      }
| exp GT exp    {
                $$=new nodeComparatorExp(
                  nodeComparatorExp::Comparator::GT, $1, $3);
                }
| exp LT exp    {
                $$=new nodeComparatorExp(
                  nodeComparatorExp::Comparator::LT, $1, $3);
                }
| exp EQ exp    {
                $$=new nodeComparatorExp(
                  nodeComparatorExp::Comparator::EQ, $1, $3);
                }
| exp NEQ exp   {
                $$=new nodeComparatorExp(
                  nodeComparatorExp::Comparator::NEQ, $1, $3);
                }
| exp LEQ exp   {
                $$=new nodeComparatorExp(
                  nodeComparatorExp::Comparator::LEQ, $1, $3);
                }
| exp GEQ exp   {
                $$=new nodeComparatorExp(
                  nodeComparatorExp::Comparator::GEQ, $1, $3);
                }
| newexp        {
                $$=$1;
                }
;

newexp:
NEW identifier paramList              {
                                      $$=new nodeNewExp($2, $3, 0);
                                      }
| newType bracketexps multibrackets   {
                                      $$=new nodeNewExp($1, $2, $3);
                                      }
| newType bracketexps                 {
                                      $$=new nodeNewExp($1, $2);
                                      }
| newType multibrackets               {
                                      $$=new nodeNewExp($1, 0, $2);
                                      }
;

UnaryOp:
MINUS exp   {
            $$=new NodeNegative($2);
            }
| PLUS exp  {
            $$=new NodePositive($2);
            }
| NOT exp   {
            $$=new NodeNot($2);
            }
;

paramList:
LPAREN RPAREN           {
                        $$=new NodeParamList(0);
                        }
| LPAREN Arglist RPAREN {
                        $$=new NodeParamList($2);
                        }
;

newType:
NEW SimpleType      {
                    $$=$2;
                    }
;

name:
THIS                  {
                      $$=new NodeThis();
                      }
| identifier          {
                      $$=$1;
                      }
| name DOT identifier {
                      $$=new nodeDot($1,$3);
                      }
| name bracketexps    {
                      $$=new Node($1,$2);
                      }
;

bracketexps:
bracketexp                {
                          $$=$1;
                          }
| bracketexps bracketexp  {
                          $$=new Node($1,$2);
                          }
;

bracketexp:
LBRACK exp RBRACK       {
                        $$=new nodeBracketExp($2);
                        } 
;

multibrackets:
LBRACK RBRACK                 {
                              $$=new NodeEmptyBrackets();
                              }
| multibrackets LBRACK RBRACK {
                              $$=new NodeEmptyBrackets($1);
                              }
;

type:
SimpleType            {
                      $$=$1;
                      }
| type LBRACK RBRACK  {
                      $$=new NodeTypeBracket($1);
                      }
;

SimpleType:
INT           {
              $$=new NodeSimpleType();
              }
| identifier  {
              $$=$1;
              }
;

identifier:
IDENT           {
                $$=new NodeIdentifier(yytext());
                }
;
%%
